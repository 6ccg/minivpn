package wire

import (
	"crypto"
	"crypto/aes"
	"crypto/cipher"
	"crypto/hmac"
	_ "crypto/sha1"
	_ "crypto/sha256"
	_ "crypto/sha512"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"strings"
)

// Debug helper: check if a debug env var is enabled
func debugEnabled(_ string) bool {
	return false
}

// The auth keys provided by the server are 64 bytes, but tls-auth
// only uses the first digest_size bytes.
const CONTROL_CHANNEL_KEY_TOTAL_LENGTH = 64

// These keys are utilised by two control channel security features:
// - all except "none" - Generating an verifying HMAC digest
// - tls-crypt(-v2) - Encrypting/Decrypting control packet contents
type ControlChannelKey [CONTROL_CHANNEL_KEY_TOTAL_LENGTH]byte

// Despite the fact that the key material generated by OpenVPN is 64 bytes
// long, only a prefix of the key is used for crypto operations
const TLS_CRYPT_KEY_LENGTH = 32

// HMAC signature used for tls-crypt
type SHA256HMACDigest [32]byte

const (
	OVPN_STATIC_KEY_BEGIN       = "-----BEGINOpenVPNStatickeyV1-----"
	OVPN_STATIC_KEY_END         = "-----ENDOpenVPNStatickeyV1-----"
	OVPN_TLS_CRYPT_V2_KEY_BEGIN = "-----BEGINOpenVPNtls-crypt-v2clientkey-----"
	OVPN_TLS_CRYPT_V2_KEY_END   = "-----ENDOpenVPNtls-crypt-v2clientkey-----"
)

var errParsingTLSAuth = errors.New("error parsing provided tls-auth key")

type ControlSecurityMode int

const (
	ControlSecurityModeNone ControlSecurityMode = iota
	ControlSecurityModeTLSAuth
	ControlSecurityModeTLSCrypt
	ControlSecurityModeTLSCryptV2
)

type ControlChannelSecurity struct {
	// Determines the type of control channel security in use
	Mode ControlSecurityMode

	// Used by ParsePacket() to verify HMAC digest provided by server + decrypt control channel
	RemoteCipherKey *ControlChannelKey
	RemoteDigestKey *ControlChannelKey

	// Used by SerializePacket() to calculate HMAC digest + encrypt control channel
	LocalCipherKey *ControlChannelKey
	LocalDigestKey *ControlChannelKey

	// Used exclusively for tls-cryptv2 (WKc)
	WrappedClientKey []byte

	// TLSAuthDigest is the message digest algorithm used for tls-auth HMAC.
	//
	// OpenVPN uses `--auth` to select the digest for tls-auth, and uses
	// exactly digest_size bytes of the 64-byte static key as the HMAC key.
	// When unset, OpenVPN defaults to SHA1.
	TLSAuthDigest crypto.Hash
}

// Accepts a OpenVPN Static key V1 PEM formatted block and extracts the
func NewControlChannelSecurityTLSAuth(encoded []byte, direction int, auth string) (*ControlChannelSecurity, error) {
	digest, err := tlsAuthDigestFromAuth(auth)
	if err != nil {
		return nil, err
	}
	keyLen := digest.Size()
	if keyLen <= 0 || keyLen > CONTROL_CHANNEL_KEY_TOTAL_LENGTH {
		return nil, fmt.Errorf("%w: unsupported tls-auth digest size: %d", errParsingTLSAuth, keyLen)
	}

	buf, err := extractStaticKeyData(encoded)
	if err != nil {
		return nil, err
	}

	// Debug: show all 4 key chunks
	if debugEnabled("MINIVPN_DEBUG_KEY") {
		n := len(buf) / 4
		log.Printf("[DEBUG-KEY] TLS-AUTH Static key total len: %d", len(buf))
		log.Printf("[DEBUG-KEY] Key chunk 0 (0-%d):     %x", n, buf[0:n])
		log.Printf("[DEBUG-KEY] Key chunk 1 (%d-%d):   %x", n, 2*n, buf[n:2*n])
		log.Printf("[DEBUG-KEY] Key chunk 2 (%d-%d):  %x", 2*n, 3*n, buf[2*n:3*n])
		log.Printf("[DEBUG-KEY] Key chunk 3 (%d-%d):  %x", 3*n, 4*n, buf[3*n:4*n])
		log.Printf("[DEBUG-KEY] Direction: %d", direction)
	}

	// keyData can be divided into 4 equal sized "chunks" e.g. [..., a, ..., b]
	// OpenVPN uses the first digest_size bytes of the chunk as the HMAC key.
	n := len(buf) / 4
	a := buf[n : n+CONTROL_CHANNEL_KEY_TOTAL_LENGTH]
	b := buf[3*n : 3*n+CONTROL_CHANNEL_KEY_TOTAL_LENGTH]

	// Debug: show which indices are being used
	if debugEnabled("MINIVPN_DEBUG_KEY") {
		log.Printf("[DEBUG-KEY] Current code uses: a=buf[%d:%d] (index 1), b=buf[%d:%d] (index 3)",
			n, n+CONTROL_CHANNEL_KEY_TOTAL_LENGTH, 3*n, 3*n+CONTROL_CHANNEL_KEY_TOTAL_LENGTH)
		log.Printf("[DEBUG-KEY] Key 'a' (first %d bytes): %x", keyLen, a[:keyLen])
		log.Printf("[DEBUG-KEY] Key 'b' (first %d bytes): %x", keyLen, b[:keyLen])
	}

	var localDigestKey, remoteDigestKey ControlChannelKey
	switch direction {
	case 0:
		copy(localDigestKey[:], a)
		copy(remoteDigestKey[:], b)
	case 1:
		copy(localDigestKey[:], b)
		copy(remoteDigestKey[:], a)
	case -1:
		// Bidirectional mode (OpenVPN default when key-direction is unset).
		copy(localDigestKey[:], a)
		copy(remoteDigestKey[:], a)
	default:
		return nil, fmt.Errorf("%w: invalid key direction: %d", errParsingTLSAuth, direction)
	}

	// Debug: show final key assignment
	if debugEnabled("MINIVPN_DEBUG_KEY") {
		log.Printf("[DEBUG-KEY] Final LocalDigestKey (first %d):  %x", keyLen, localDigestKey[:keyLen])
		log.Printf("[DEBUG-KEY] Final RemoteDigestKey (first %d): %x", keyLen, remoteDigestKey[:keyLen])
	}

	return &ControlChannelSecurity{
		Mode:            ControlSecurityModeTLSAuth,
		LocalDigestKey:  &localDigestKey,
		RemoteDigestKey: &remoteDigestKey,
		TLSAuthDigest:   digest,
	}, nil
}

// Accepts a OpenVPN Static key V1 PEM formatted block and extracts into a PacketAuth struct
func NewControlChannelSecurityTLSCrypt(encoded []byte) (*ControlChannelSecurity, error) {
	buf, err := extractStaticKeyData(encoded)
	if err != nil {
		return nil, err
	}

	n := len(buf) / 4
	var localCipherKey, localDigestKey, remoteCipherKey, remoteDigestKey ControlChannelKey
	copy(remoteCipherKey[:], buf[:n])
	copy(remoteDigestKey[:], buf[n:2*n])
	copy(localCipherKey[:], buf[2*n:3*n])
	copy(localDigestKey[:], buf[3*n:])
	return &ControlChannelSecurity{Mode: ControlSecurityModeTLSCrypt, RemoteCipherKey: &remoteCipherKey, RemoteDigestKey: &remoteDigestKey, LocalCipherKey: &localCipherKey, LocalDigestKey: &localDigestKey}, nil
}

// "static" keys are used by tls-auth and tls-crypt modes.
// (fixed_header | hexadecimal key data | fixed_trailer)
func extractStaticKeyData(encoded []byte) ([]byte, error) {
	s := strings.ReplaceAll(string(encoded), "\n", "")
	s = strings.ReplaceAll(s, "\r", "")
	s = strings.ReplaceAll(s, " ", "")

	s = strings.TrimPrefix(s, OVPN_STATIC_KEY_BEGIN)
	s = strings.TrimSuffix(s, OVPN_STATIC_KEY_END)

	return hex.DecodeString(s)
}

func NewControlChannelSecurityTLSCryptV2(encoded []byte) (*ControlChannelSecurity, error) {
	b, err := extractCryptV2KeyData(encoded)
	if err != nil {
		return nil, err
	}

	// The tls-crypt-v2 block first contains 4 * AUTH_KEY_TOTAL_LENGTH keys, then a variable length WrappedClientKey
	keyData := b[:4*CONTROL_CHANNEL_KEY_TOTAL_LENGTH]
	WKc := b[4*CONTROL_CHANNEL_KEY_TOTAL_LENGTH:]

	n := len(keyData) / 4
	var localCipherKey, localDigestKey, remoteCipherKey, remoteDigestKey ControlChannelKey
	copy(remoteCipherKey[:], keyData[:n])
	copy(remoteDigestKey[:], keyData[n:2*n])
	copy(localCipherKey[:], keyData[2*n:3*n])
	copy(localDigestKey[:], keyData[3*n:])

	return &ControlChannelSecurity{
		Mode:             ControlSecurityModeTLSCryptV2,
		RemoteCipherKey:  &remoteCipherKey,
		RemoteDigestKey:  &remoteDigestKey,
		LocalCipherKey:   &localCipherKey,
		LocalDigestKey:   &localDigestKey,
		WrappedClientKey: WKc,
	}, nil
}

// "crypt-v2" keys are used only by tls-crypt-v2.
// (fixed_header | base64 key data | fixed_trailer)
func extractCryptV2KeyData(encoded []byte) ([]byte, error) {
	s := strings.ReplaceAll(string(encoded), "\n", "")
	s = strings.ReplaceAll(s, "\r", "")
	s = strings.ReplaceAll(s, " ", "")

	s = strings.TrimPrefix(s, OVPN_TLS_CRYPT_V2_KEY_BEGIN)
	s = strings.TrimSuffix(s, OVPN_TLS_CRYPT_V2_KEY_END)

	return base64.StdEncoding.DecodeString(s)
}

func GenerateTLSAuthDigest(digest crypto.Hash, key *ControlChannelKey, header []byte, replay []byte, message []byte) []byte {
	if digest == 0 {
		digest = crypto.SHA1
	}
	keyLen := digest.Size()

	// Debug: show HMAC inputs
	if debugEnabled("MINIVPN_DEBUG_HMAC") {
		log.Printf("[DEBUG-HMAC] GenerateTLSAuthDigest inputs:")
		log.Printf("[DEBUG-HMAC]   digest: %s", digest.String())
		log.Printf("[DEBUG-HMAC]   key (first %d): %x", keyLen, key[:keyLen])
		log.Printf("[DEBUG-HMAC]   replay (%d bytes): %x", len(replay), replay)
		log.Printf("[DEBUG-HMAC]   header (%d bytes): %x", len(header), header)
		log.Printf("[DEBUG-HMAC]   message (%d bytes): %x", len(message), message)
		log.Printf("[DEBUG-HMAC]   HMAC order: replay || header || message")
	}

	h := hmac.New(digest.New, key[:keyLen])

	h.Write(replay)
	h.Write(header)
	h.Write(message)

	sig := h.Sum(nil)

	// Debug: show HMAC output
	if debugEnabled("MINIVPN_DEBUG_HMAC") {
		log.Printf("[DEBUG-HMAC]   output: %x", sig)
	}

	return sig
}

func GenerateTLSCryptDigest(key *ControlChannelKey, header []byte, replay []byte, message []byte) SHA256HMACDigest {
	h := hmac.New(crypto.SHA256.New, key[:TLS_CRYPT_KEY_LENGTH])

	// N.B. order of packet chunks is different to tls-auth
	h.Write(header)
	h.Write(replay)
	h.Write(message)

	sig := h.Sum(nil)
	return SHA256HMACDigest(sig)
}

func EncryptControlMessage(hmac SHA256HMACDigest, key ControlChannelKey, msg []byte) ([]byte, error) {
	return doControlEncryptionXOR(hmac, key, msg)
}

func DecryptControlMessage(hmac SHA256HMACDigest, key ControlChannelKey, ct []byte) ([]byte, error) {
	return doControlEncryptionXOR(hmac, key, ct)
}

// Since performing an XOR with the key stream is a symmetric function, the
// exact same operation can be performed for both encryption and decryption
// of the encrypted portion of tls-crypt(-v2) packets
func doControlEncryptionXOR(hmac SHA256HMACDigest, key ControlChannelKey, in []byte) ([]byte, error) {
	out := make([]byte, len(in))

	// OpenVPN uses first 16 bytes of HMAC as IV
	iv := hmac[:16]

	// 3. AES-256-CTR encryption
	block, err := aes.NewCipher(key[:32]) // only use first 32 bytes
	if err != nil {
		return out, err
	}
	ctr := cipher.NewCTR(block, iv)

	ctr.XORKeyStream(out, in)

	return out, nil
}

func tlsAuthDigestFromAuth(auth string) (crypto.Hash, error) {
	auth = strings.TrimSpace(auth)
	if auth == "" {
		auth = "SHA1"
	}

	var digest crypto.Hash
	switch strings.ToUpper(auth) {
	case "SHA1":
		digest = crypto.SHA1
	case "SHA256":
		digest = crypto.SHA256
	case "SHA512":
		digest = crypto.SHA512
	default:
		return 0, fmt.Errorf("%w: unsupported tls-auth digest: %s", errParsingTLSAuth, auth)
	}

	if !digest.Available() {
		return 0, fmt.Errorf("%w: tls-auth digest is not available: %s", errParsingTLSAuth, auth)
	}
	return digest, nil
}
